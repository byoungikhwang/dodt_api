### 2025-12-24 UI 변경사항 적용 보고

**수정 목표:**
사용자 요청에 따라 메인 페이지(`index.html`) 및 둘러보기 페이지(`feed.html`)의 UI를 업데이트하고, `feed.html`의 동적 피드 기능을 활성화합니다.

**변경 내용:**

1.  **`app/templates/index.html` 수정:**
    *   **기존 동적 피드 기능 제거:** `index.html`에 존재하던 단일 컬럼 비디오 피드 로직을 모두 제거했습니다.
    *   **메인 비디오 추가:** 페이지 상단에 `/static/videos/nas.mp4` 비디오를 9:16 비율로 자동 재생되도록 추가했습니다.
    *   **피드 미리보기 섹션 추가:** 메인 비디오 아래에 2열 그리드 레이아웃의 피드 미리보기 섹션을 구현했습니다. 임시 이미지 6개를 사용하여 마우스를 올렸을 때 제작자 정보와 '좋아요' 아이콘 및 카운트가 표시되도록 디자인 명세에 맞춰 배치했습니다.

2.  **`app/templates/feed.html` 수정:**
    *   **임시 비디오 제거:** 기존에 백엔드 문제로 인해 임시로 표시되던 하드코딩된 `nas.mp4` 비디오 블록을 제거했습니다.
    *   **동적 피드 기능 활성화:** `feed.html` 내의 JavaScript 코드에서 주석 처리되어 있던 `fetchFeed(true);` 호출을 해제하여, 2열 무한 스크롤, 검색, 인기순/최신순 정렬 등 기존에 구현되어 있던 동적 피드 로직이 정상적으로 작동하도록 활성화했습니다.

**영향 범위:**
`index.html`은 이제 정적인 메인 비디오 및 피드 미리보기를 제공하며, `feed.html`은 사용자 요구사항에 맞춰 동적으로 미디어 콘텐츠를 불러와 표시하게 됩니다.

---
### 2025-12-24 백엔드 오류 수정 보고

**수정 목표:**
서버 시작 오류(`ERR_ADDRESS_INVALID`) 및 `/api/media` 엔드포인트의 500 내부 서버 오류를 해결하여 애플리케이션의 정상 작동을 복구합니다.

**변경 내용:**

1.  **`.env` 파일 `POSTGRES_PASSWORD` 업데이트:**
    *   사용자 입력에 따라 `POSTGRES_PASSWORD` 값을 `admin`에서 `admin123`으로 수정하여 데이터베이스 인증 실패 문제를 해결했습니다.

2.  **`app/main.py` 시작 이벤트 로직 수정:**
    *   `startup_event` 함수 내에서 데이터베이스 연결 풀 생성 실패 시 예외를 다시 발생(`raise e`)시키도록 수정했습니다. 이로써 애플리케이션이 데이터베이스 연결 없이는 시작되지 않고, 시작 실패 시 명확한 오류 메시지를 출력하며 종료되도록 하여 디버깅 효율성을 높였습니다.

3.  **`app/routers/index_router.py` 오류 수정:**
    *   `get_media_feed` 함수에서 `media_service.get_all_media(conn)` 대신 올바른 메서드인 `media_service.get_feed_media()`를 호출하도록 수정했습니다. 메인 페이지 미리보기 목적에 맞춰 `sort='popular'`, `limit=6`, `offset=0` 및 현재 사용자 ID를 매개변수로 전달하도록 구현했습니다. 이 수정으로 인해 `AttributeError: 'MediaService' object has no attribute 'get_all_media'` 오류가 해결되었습니다.

**영향 범위:**
`index.html` 및 `feed.html`에서 `/api/media` 엔드포인트를 통해 데이터를 요청할 때 발생하던 500 내부 서버 오류가 해결되었습니다. 애플리케이션 시작 시 데이터베이스 연결 실패 시점부터 명확하게 인지하고 대처할 수 있게 되었습니다.

---
### 2025-12-24 Google OAuth 'invalid_client' 오류 수정

**수정 목표:**
`.env` 파일의 내용이 정확하다는 전제 하에, Google OAuth 로그인 시 발생하는 `401 invalid_client` 오류를 해결합니다.

**변경 내용:**

*   **`app/routers/auth_router.py` 라우터 경로 수정:**
    *   Google로부터 인증 코드를 받아 처리하는 콜백 함수의 라우터 경로를 `@router.get("/rest/oauth2-credential/callback")`에서 `@router.get("/auth/callback")`으로 수정했습니다.
    *   **이유:** `.env` 파일에 설정된 `GOOGLE_REDIRECT_URI`(http://localhost:8000/auth/callback)와 실제 애플리케이션의 콜백 엔드포인트 주소가 일치하지 않아 `invalid_client` 오류가 발생했습니다. 이번 수정으로 두 경로를 일치시켜 문제를 해결했습니다.

**영향 범위:**
이 수정으로 인해, `.env` 파일에 올바른 `GOOGLE_CLIENT_ID`와 `GOOGLE_CLIENT_SECRET`이 설정되어 있다면 Google 로그인이 정상적으로 작동해야 합니다.

---
### 2025-12-24 `TypeError: unexpected keyword argument 'user_id'` 오류 수정

**수정 목표:**
`media_service.get_feed_media()` 메서드 호출 시 발생하는 `TypeError: unexpected keyword argument 'user_id'` 오류를 해결합니다. 이 오류는 서비스 메서드의 인자 이름 불일치로 인해 발생했습니다.

**변경 내용:**

1.  **`app/routers/index_router.py` 수정:**
    *   `get_media_feed` 함수 내에서 `media_service.get_feed_media`를 호출할 때 `user_id` 대신 `current_user_id` 인자를 사용하도록 수정했습니다.
    *   관련 로컬 변수명도 `user_id`에서 `current_user_id`로 변경하여 일관성을 확보했습니다.

2.  **`app/routers/media_router.py` 수정:**
    *   `get_feed_media` 함수 내에서 `media_service.get_feed_media`를 호출할 때 `user_id` 대신 `current_user_id` 인자를 사용하도록 수정했습니다.
    *   관련 로컬 변수명도 `user_id`에서 `current_user_id`로 변경하여 일관성을 확보했습니다.

**원인:**
`app/services/media_service.py`의 `get_feed_media` 메서드는 `current_user_id`라는 인자 이름을 기대했지만, `index_router.py`와 `media_router.py`에서 `user_id`라는 이름으로 인자를 전달하려고 시도하여 불일치가 발생했습니다.

**영향 범위:**
이 수정으로 인해 `/api/media` 엔드포인트 호출 시 발생하던 `TypeError`가 해결되었으며, 애플리케이션의 피드 관련 기능이 정상적으로 작동할 것입니다.

---
# 2025-12-24_17_10.md

## File: app/main.py

### Description
- Added `SessionMiddleware` to handle user sessions, which is necessary for implementing the OAuth `state` parameter for CSRF protection.
- The middleware is configured with the `SECRET_KEY` from the application settings.

### Code Change
```python
# app/main.py

# Add imports for SessionMiddleware
from starlette.middleware.sessions import SessionMiddleware

# ... (existing code)

app = FastAPI(title=settings.PROJECT_NAME, version=settings.PROJECT_VERSION)

# Middleware
app.add_middleware(LoggingMiddleware)
# Add SessionMiddleware
app.add_middleware(SessionMiddleware, secret_key=settings.SECRET_KEY)


# ... (rest of the file)
```
# 2025-12-24_17_12.md

## File: app/routers/auth_router.py

### Description
- **CSRF Protection:** Implemented CSRF protection in the Google OAuth2 flow by using the `state` parameter.
- The `/login/google` endpoint now generates a secure random token (`state`), stores it in the user's session, and passes it to Google's authentication URL.
- The `/auth/callback` endpoint verifies that the `state` parameter returned from Google matches the one stored in the session. If they do not match, an `HTTPException` is raised, preventing the login process.
- This change mitigates the risk of Cross-Site Request Forgery attacks.

### Code Change
```python
# app/routers/auth_router.py

# Add 'secrets' import
import secrets
# ... (existing imports)

# ... (existing code before google_callback)

@router.get("/auth/callback")
async def google_callback(request: Request, code: str, state: str, user_service: UserService = Depends(), conn: asyncpg.Connection = Depends(get_db_connection)):
    # Verify state to prevent CSRF
    if state != request.session.pop("state", None):
        raise HTTPException(status_code=403, detail="Invalid state token")

    token_url = "https://oauth2.googleapis.com/token"
    # ... (rest of the function is the same)

# ... (existing code before login_google)

@router.get("/login/google")
async def login_google(request: Request):
    # Generate and store state for CSRF protection
    state = secrets.token_urlsafe(32)
    request.session["state"] = state
    return RedirectResponse(
        f"https://accounts.google.com/o/oauth2/auth?response_type=code&client_id={GOOGLE_CLIENT_ID}&redirect_uri={GOOGLE_REDIRECT_URI}&scope=openid%20email%20profile&access_type=offline&state={state}"
    )

# ... (rest of the file)
```
# 2025-12-24_17_15.md

## File: app/services/users_service.py

### Description
- **Race Condition Fix:** Resolved a race condition in the `get_or_create_user` function.
- The original implementation used a "check-then-act" pattern, which could fail under concurrent requests for the same new user, leading to a `UniqueViolationError` from the database.
- The updated logic now attempts to create the user directly within a `try...except` block.
- If the user creation fails because the email already exists (a `UniqueViolationError`), the `except` block catches the error, fetches the existing user from the database, and then proceeds with the daily credit check logic.
- This "ask for forgiveness, not permission" approach ensures that user creation is atomic and safe from race conditions.
- Also, added logging to be aware of when the race condition is handled.

### Code Change
```python
# app/services/users_service.py

import logging
# ... (other imports)

logger = logging.getLogger(__name__)

class UserService:
    # ... (other methods)

    async def get_or_create_user(self, conn: asyncpg.Connection, email: str, name: str, picture: str):
        try:
            # First, attempt to create the user. This is the "optimistic" or "ask for forgiveness" approach.
            custom_id_exists = True
            generated_custom_id = ""
            while custom_id_exists:
                generated_custom_id = self._generate_custom_id()
                # Check if custom_id already exists
                existing_user_with_id = await self.user_repo.get_user_by_custom_id(conn, generated_custom_id)
                if not existing_user_with_id:
                    custom_id_exists = False

            initial_credits = 1
            today = date.today()
            user = await self.user_repo.create_user(
                conn, email, generated_custom_id, name, picture, role="MEMBER",
                credits=initial_credits, last_credit_grant_date=today
            )
            # If creation is successful, the new user is returned.
            return user
        except asyncpg.UniqueViolationError:
            # If a UniqueViolationError occurs, it means the user was likely created by a concurrent request.
            logger.info(f"Race condition handled: User with email {email} already exists. Fetching existing user.")
            await conn.execute('ROLLBACK') # Rollback the failed transaction
            
            # Now, we can safely fetch the existing user.
            user = await self.user_repo.get_user_by_email(conn, email)
            if not user:
                # This case is highly unlikely but handled for safety.
                raise HTTPException(status_code=500, detail="Failed to retrieve user after race condition.")

            # Proceed with the daily credit check for the existing user.
            last_grant_date_db = user["last_credit_grant_date"]
            if isinstance(last_grant_date_db, datetime):
                last_grant_date_obj = last_grant_date_db.date()
            elif isinstance(last_grant_date_db, date):
                last_grant_date_obj = last_grant_date_db
            else:
                last_grant_date_obj = date(1970, 1, 1)

            await self._check_and_grant_daily_credit(conn, user["id"], user["credits"], last_grant_date_obj)
            
            # Re-fetch the user to get the most up-to-date credit information.
            user = await self.user_repo.get_user_by_id(conn, user["id"])
            return user
```
# 2025-12-24_17_20.md

## File: app/config/settings.py

### Description
- **Configuration Cleanup:** Refactored the database connection settings for clarity and consistency.
- Removed the redundant and unused `POSTGRES_SERVER` setting.
- Renamed `db_host` to `POSTGRES_HOST` to align with the existing `POSTGRES_` naming convention. `db_port` was already named `POSTGRES_PORT`.
- Updated the `DATABASE_URL` computed field to use the new, consistent variable names (`POSTGRES_HOST`, `POSTGRES_PORT`).
- Removed obsolete comments related to the previous confusing variable names.
- This change makes the configuration cleaner and less prone to errors.

### Code Change
```python
# app/config/settings.py

class Settings(BaseSettings):
    PROJECT_NAME: str = "AI Persona Customer Survey"
    PROJECT_VERSION: str = "0.9.0"

    # The .env file will be loaded automatically by BaseSettings
    POSTGRES_USER: str
    POSTGRES_PASSWORD: str
    POSTGRES_HOST: str = "localhost" # Renamed from db_host
    POSTGRES_PORT: int = 5432       # Standardized name
    POSTGRES_DB: str = "tdd"

    # ... (other settings) ...

    @computed_field
    @property
    def DATABASE_URL(self) -> str:
        return f"postgresql://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}"

    # ... (rest of the file)
```
# 2025-12-24_17_22.md

## File: app/services/users_service.py

### Description
- **Code Quality Improvement:** Simplified the date handling logic in the `get_or_create_user` function.
- The previous implementation contained overly defensive code to handle cases where `last_credit_grant_date` could be a `datetime` object, a `date` object, or `None`.
- Given that the database schema defines the column as `DATE`, the `datetime` check is redundant.
- The logic has been simplified to expect a `date` object. If the value is `None` or an unexpected type, it defaults to a very old date to ensure the daily credit is granted correctly, thus maintaining robustness while improving readability.

### Code Change
```python
# app/services/users_service.py

# ... (inside get_or_create_user's except block)

            # Proceed with the daily credit check for the existing user.
            last_grant_date = user["last_credit_grant_date"]
            if not isinstance(last_grant_date, date):
                # If it's None or some other unexpected type, treat as a grant-requiring date.
                last_grant_date = date(1970, 1, 1)

            await self._check_and_grant_daily_credit(conn, user["id"], user["credits"], last_grant_date)
            
            # Re-fetch the user to get the most up-to-date credit information.
            user = await self.user_repo.get_user_by_id(conn, user["id"])
            return user
```
