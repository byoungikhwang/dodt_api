# 2025-12-26_10-06_settings_py_update.md

## `app/config/settings.py` 파일 수정 내역

### 변경 이유
Pydantic v2의 최신 권장 설정 방식을 따르고, `.env` 파일 로딩의 일관성을 확보하며, DB 설정 변수명을 명확히 하여 코드의 가독성과 유지보수성을 향상시키기 위함입니다. 또한, Deprecated된 기능을 최신 표준으로 업데이트합니다.

### 변경 사항 요약
1.  **`.env` 파일 로딩 방식 개선:**
    *   `dotenv.load_dotenv()` 수동 호출 제거.
    *   `pydantic_settings.BaseSettings`가 `.env` 파일을 자동으로 처리하도록 변경.
2.  **DB 설정 변수명 통일:**
    *   `POSTGRES_HOST`를 `.env`의 키값과 일치하는 `POSTGRES_SERVER`로 변경.
    *   `DATABASE_URL` computed field에서 변경된 `POSTGRES_SERVER` 변수명 반영.
3.  **DB 이름 기본값 처리:**
    *   `POSTGRES_DB`의 기본값을 `.env`와 일치하도록 "main_db"로 설정하여 혼동 방지.
4.  **Pydantic 설정 스타일 업데이트:**
    *   Deprecated된 `class Config:` 대신 `model_config = SettingsConfigDict(...)` 사용.
    *   `extra='ignore'` 옵션을 추가하여, `.env`에 정의되었으나 모델에 없는 변수가 있을 경우 에러를 방지.

### 코드 변경 전후 (참고)

**수정 전 (주요 변경점):**
```python
from pydantic import computed_field
from dotenv import load_dotenv # Import load_dotenv

load_dotenv() # Explicitly load .env file

class Settings(BaseSettings):
    # ...
    POSTGRES_HOST: str = "localhost"
    # ...
    POSTGRES_DB: str = "tdd"
    # ...
    @computed_field
    @property
    def DATABASE_URL(self) -> str:
        return f"postgresql://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}"
    # ...
    class Config:
        env_file = ".env"
        env_file_encoding = 'utf-8'
```

**수정 후 (주요 변경점):**
```python
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import computed_field
# [수정 전] 불필요한 라이브러리 및 중복 로드
# from dotenv import load_dotenv # Import load_dotenv
# load_dotenv() # Explicitly load .env file

# [수정 후] Pydantic의 BaseSettings가 자동으로 .env를 읽으므로 수동 로드는 제거합니다.
# (이중 로드는 설정 우선순위 혼동을 야기할 수 있습니다.)

class Settings(BaseSettings):
    # ...
    # [수정 전] .env 파일의 변수명(POSTGRES_SERVER)과 불일치
    # POSTGRES_HOST: str = "localhost"
    
    # [수정 후] .env 파일의 키값인 POSTGRES_SERVER로 변수명 통일
    POSTGRES_SERVER: str = "localhost"
    # ...
    # [수정 전] .env 값(main_db)과 다른 기본값 사용으로 혼동 우려
    # POSTGRES_DB: str = "tdd"
    
    # [수정 후] 기본값을 제거하거나 .env와 맞춥니다. (여기선 타입을 명시하고 기본값은 .env에 위임)
    POSTGRES_DB: str = "main_db"
    # ...
    @computed_field @property
    def DATABASE_URL(self) -> str:
        # [수정 전] self.POSTGRES_HOST 사용 (변수명 변경으로 인해 에러 발생 가능성)
        # return f"postgresql://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD} @{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}"
        
        # [수정 후] 변경된 변수명(POSTGRES_SERVER) 적용 및 asyncpg 프로토콜 명시
        # 참고: 비밀번호에 특수문자가 있을 경우 URL 인코딩이 필요할 수 있으나, 현재는 기본 구조를 유지합니다.
        return f"postgresql://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_SERVER}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}"
    # ...
    # [수정 전] Pydantic V1 스타일의 Config 클래스 (Deprecated 예정)
    # class Config:
    #     # This tells pydantic to load variables from a .env file
    #     # env_file = ".env"
    #     # env_file_encoding = 'utf-8'

    # [수정 후] Pydantic V2 권장 스타일 (model_config 사용)
    # extra='ignore' 옵션은 .env에 정의되었지만 이 클래스에 없는 변수(예: db_host 등)가 있어도 에러를 내지 않도록 합니다.
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore"
    )
```

# 2025-12-26_10-57 - Repository Pattern Refactoring

## 1. 개요

본 문서는 API 서버의 데이터베이스 접근 로직을 **리포지토리 패턴(Repository Pattern)** 으로 리팩토링한 내역을 기록합니다. 이 작업의 주된 목적은 '관심사의 분리(Separation of Concerns)' 원칙을 적용하여, 비즈니스 로직(라우터)과 데이터 영속성 로직(DB 쿼리)을 명확하게 분리하는 것입니다.

### 기대 효과
- **유지보수성 향상**: 데이터베이스 관련 코드가 리포지토리 모듈에 집중되어 있어 수정 및 관리가 용이합니다.
- **테스트 용이성 증대**: 라우터 테스트 시, 실제 DB 대신 모의(Mock) 리포지토리를 주입하여 단위 테스트를 쉽게 작성할 수 있습니다.
- **코드 재사용성 증가**: 여러 라우터에서 동일한 데이터베이스 쿼리가 필요할 경우, 해당 리포지토리 메서드를 재사용할 수 있습니다.
- **가독성 및 일관성**: 프로젝트 전반에 걸쳐 일관된 데이터 접근 방식을 적용하여 코드 가독성을 높입니다.

## 2. 변경된 파일 목록

### 생성된 파일
- `app/schemas.py`
- `app/repositories/analysis_repository.py`
- `app/dependencies/repositories.py`

### 수정된 파일
- `app/repositories/users_repository.py`
- `app/routers/user_router.py`

## 3. 세부 변경 내역

### 3.1. `app/schemas.py` (생성)
- **목적**: 데이터베이스 모델과 API 응답/요청 본문의 형태를 정의하는 Pydantic 스키마를 중앙에서 관리합니다.
- **주요 내용**:
    - `UserBase`, `UserCreate`, `User` 등 사용자 관련 스키마를 정의했습니다.
    - `AnalysisResultBase`, `AnalysisResult` 등 분석 결과 관련 스키마를 정의했습니다.
    - 이를 통해 API의 명세를 명확히 하고, 타입 안정성을 강화했습니다.

### 3.2. `app/repositories/users_repository.py` (수정)
- **목적**: 사용자(users) 테이블에 대한 모든 CRUD(Create, Read, Update, Delete) 작업을 캡슐화합니다.
- **주요 내용**:
    - 제공된 코드로 파일 내용을 업데이트하여, 사용자 관련 데이터베이스 로직을 `UserRepository` 클래스로 통합했습니다.

### 3.3. `app/repositories/analysis_repository.py` (생성)
- **목적**: 분석 결과(analysis_results) 테이블에 대한 데이터 접근 로직을 분리합니다.
- **주요 내용**:
    - `AnalysisRepository` 클래스를 생성했습니다.
    - 기존에 `user_router.py`에 있던 '사용자의 분석 기록 조회' SQL 쿼리를 `get_analysis_history_by_user_id` 메서드로 이전했습니다.
    - 쿼리 결과를 Pydantic 모델(`AnalysisResult`)로 변환하여 반환하도록 구현했습니다.

### 3.4. `app/dependencies/repositories.py` (생성 및 수정)
- **목적**: 생성된 리포지토리들을 FastAPI의 의존성 주입(Dependency Injection) 시스템을 통해 라우터에 제공합니다.
- **주요 내용**:
    - DB 커넥션을 받아 `UserRepository` 인스턴스를 생성하는 `get_user_repository` 함수를 추가했습니다.
    - DB 커넥션을 받아 `AnalysisRepository` 인스턴스를 생성하는 `get_analysis_repository` 함수를 추가했습니다.

### 3.5. `app/routers/user_router.py` (수정)
- **목적**: 라우터가 더 이상 데이터베이스에 직접 접근하지 않고, 리포지토리를 통해 데이터를 조회하도록 변경합니다.
- **주요 내용**:
    - `/profile` 엔드포인트에서 `Depends(get_db_connection)` 의존성을 제거했습니다.
    - 대신 `analysis_repo: AnalysisRepository = Depends(get_analysis_repository)`를 추가하여 `AnalysisRepository`를 주입받도록 수정했습니다.
    - 직접 실행되던 SQL 쿼리 부분을 `await analysis_repo.get_analysis_history_by_user_id(...)` 호출로 변경하여, 코드를 단순화하고 가독성을 높였습니다.

# 2025-12-26_11-15 - settings.py Decorator Order Fix

## `app/config/settings.py` 버그 수정 내역

### 문제 상황
서버 실행 시 다음과 같은 `TypeError`가 발생하며 애플리케이션이 시작되지 않았습니다.
```
TypeError: unsupported operand type(s) for @: 'function' and 'type'
```

### 원인
`app/config/settings.py` 파일 내의 `DATABASE_URL`을 정의하는 부분에서 Pydantic V2의 데코레이터 순서 규칙을 위반했습니다. `@computed_field`와 `@property`가 잘못된 순서로 적용되어 있었습니다.

### 해결 조치
Pydantic V2의 공식 문서에 따라 데코레이터의 순서를 올바르게 수정했습니다. `@property`를 `@computed_field`보다 먼저 선언하여 문제를 해결했습니다.

#### 수정 전
```python
    @computed_field 
    @property
    def DATABASE_URL(self) -> str:
        # ...
```

#### 수정 후
```python
    @property
    @computed_field
    def DATABASE_URL(self) -> str:
        # ...
```

# 2025-12-26_11-38 - ModuleNotFoundError Fix for 'itsdangerous'

## `ModuleNotFoundError: No module named 'itsdangerous'` 해결 과정

### 1. 문제 상황
서버 실행 시 다음과 같은 `ModuleNotFoundError`가 발생하며 애플리케이션이 시작되지 않았습니다.
```
ModuleNotFoundError: No module named 'itsdangerous'
```

### 2. 원인 분석
- **1차 원인**: `app/main.py`에서 사용하는 `SessionMiddleware`는 `itsdangerous` 라이브러리를 필요로 하지만, 이 패키지가 프로젝트 의존성 파일(`requirements.txt`)에 명시되어 있지 않고, 환경에 설치되지 않았습니다.
- **2차 원인 (수정 과정 중 발생)**: `requirements.txt`에 `itsdangerous`를 추가하는 과정에서 줄 바꿈 처리가 누락되어, 기존의 `python-multipart`와 합쳐진 `python-multipartitsdangerous`라는 잘못된 패키지 이름이 생성되었습니다. 이로 인해 `pip install`이 실패했습니다.

### 3. 해결 조치

#### 3.1. 의존성 파일 형식 오류 수정
- `requirements.txt` 파일을 열어 잘못 합쳐진 `python-multipartitsdangerous` 라인을 다음과 같이 두 개의 개별 라인으로 수정했습니다.
  
  **수정 전:**
  ```
  ...
  python-multipartitsdangerous
  ```

  **수정 후:**
  ```
  ...
  python-multipart
  itsdangerous
  ```

#### 3.2. 의존성 패키지 설치
- 수정된 `requirements.txt` 파일을 사용하여 `pip install -r requirements.txt` 명령을 다시 실행했습니다.
- 이를 통해 누락되었던 `itsdangerous` 패키지가 정상적으로 설치되었습니다.

이 조치를 통해 애플리케이션의 모든 필수 의존성이 올바르게 설치되었으며, `ModuleNotFoundError`가 해결되었습니다.

# 2025-12-26_12-11 - 아키텍처 리팩토링: 인증 및 서비스 계층

## 1. 개요 (Overview)

본 문서는 서버 시동 시 발생한 `FastAPIError`를 해결하고, 애플리케이션 전반의 아키텍처 일관성을 확보하기 위해 수행된 종합적인 리팩토링 내역을 기록합니다. 이 작업은 특히 인증 관련 로직(`auth_router.py`, `users_service.py`)에 집중되었습니다.

### 문제 상황 (Problem)
1.  **서버 시동 실패**: `fastapi.exceptions.FastAPIError: Invalid args for response field!... <class 'asyncpg.connection.Connection'>` 오류가 발생하며 서버가 시작되지 않았습니다.
2.  **아키텍처 비일관성**: `auth_router.py`가 이전에 적용된 리포지토리 패턴을 따르지 않고, 데이터베이스 연결(`conn`)을 직접 주입받고 서비스 계층에 다시 전달하는 안티패턴을 사용하고 있었습니다.
3.  **잘못된 의존성 주입**: `UserService`가 생성자(`__init__`)에서 `Depends()`를 사용하여 잘못된 의존성 주입 패턴을 가지고 있었습니다.

### 해결 목표 (Goal)
- 서버 시동 오류의 근본 원인을 해결합니다.
- `auth_router`와 `UserService`를 리팩토링하여 전체 애플리케이션이 일관된 **Controller -> Service -> Repository** 계층 구조를 따르도록 합니다.
- 코드의 테스트 용이성과 유지보수성을 향상시킵니다.

## 2. 변경된 파일 목록 (Changed Files)

- **수정 (Modified)**:
    - `app/services/users_service.py`
    - `app/routers/auth_router.py`
- **생성 (Created)**:
    - `app/dependencies/services.py`
- **취소 (Cancelled)**:
    - `app/repositories/users_repository.py` 수정 (분석 결과, 이미 올바르게 구현되어 있었음)

## 3. 세부 변경 내역 (Detailed Changes)

### 3.1. `app/services/users_service.py` (수정)
- **`__init__` 생성자 수정**: `Depends()`를 제거하고, `UserRepository` 인스턴스를 직접 주입받는 표준 파이썬 생성자로 변경했습니다.
- **`conn` 인자 제거**: 모든 메소드 시그니처에서 데이터베이스 연결 객체(`conn: asyncpg.Connection`)를 제거했습니다.
- **내부 로직 수정**: `self.user_repo`의 메소드를 호출할 때 `conn`을 전달하지 않도록 수정하여, 서비스가 리포지토리에만 온전히 의존하도록 변경했습니다.

### 3.2. `app/dependencies/services.py` (생성)
- **`get_user_service` 함수 생성**: `get_user_repository`를 통해 `UserRepository` 인스턴스를 받아 `UserService`를 생성하고 반환하는 새로운 의존성 주입 함수를 만들었습니다. 이는 서비스 계층의 의존성을 올바르게 관리합니다.

### 3.3. `app/routers/auth_router.py` (수정)
- **의존성 변경**:
    - `get_db_connection`에 대한 의존성을 완전히 제거했습니다.
    - `google_callback` 엔드포인트가 `user_service: UserService = Depends(get_user_service)`를 통해 올바르게 서비스 인스턴스를 주입받도록 수정했습니다.
- **코드 간소화**: `user_service.get_or_create_user` 호출 시 `conn`을 전달하는 코드를 제거하여 라우터의 책임을 명확히 했습니다.

## 4. 기대 효과 (Expected Outcome)
- `FastAPIError`가 해결되어 서버가 정상적으로 시동됩니다.
- 전체 코드가 일관된 아키텍처 패턴을 따르게 되어 예측 가능하고 유지보수가 쉬워집니다.
- 각 계층이 명확히 분리되어 향후 기능 추가 및 단위 테스트 작성이 용이해집니다.

# 2025-12-26_14-26 - 아키텍처 리팩토링: 분석 서비스 계층

## 1. 개요 (Overview)

본 문서는 `FastAPIError`로 인한 서버 시동 실패 문제를 해결하는 과정에서 발견된 `AnalysisService`의 아키텍처 문제를 해결하기 위해 수행된 종합 리팩토링 내역을 기록합니다. 이 작업은 애플리케이션의 모든 계층이 일관된 **Controller -> Service -> Repository** 패턴을 따르도록 보장하는 것을 목표로 합니다.

### 문제 상황 (Problem)
1.  **서버 시동 실패**: `auth_router.py` 문제를 해결한 후에도, `analysis_router.py`에서 발생하는 동일한 종류의 `FastAPIError`로 인해 서버가 여전히 시작되지 않았습니다.
2.  **아키텍처 위반**: `AnalysisService`가 데이터베이스 쿼리를 직접 실행하고, 라우터로부터 데이터베이스 연결(`conn`)을 주입받는 등 서비스 계층의 역할을 벗어나는 여러 책임을 가지고 있었습니다.

### 해결 목표 (Goal)
- 서버 시동 오류의 마지막 원인을 해결합니다.
- `AnalysisService`와 그 주변(`analysis_router.py`, 관련 레포지토리 및 의존성)을 리팩토링하여 전체 아키텍처의 일관성을 확보합니다.

## 2. 변경된 파일 목록 (Changed Files)

- **수정 (Modified)**:
    - `app/repositories/analysis_repository.py`
    - `app/dependencies/repositories.py`
    - `app/services/analysis_service.py`
    - `app/dependencies/services.py`
    - `app/routers/analysis_router.py`
- **생성 (Created)**:
    - `app/repositories/style_log_repository.py`

## 3. 세부 변경 내역 (Detailed Changes)

### 3.1. 레포지토리 계층 확장
- **`analysis_repository.py` (수정)**: 기존 `get_history_by_user_id` 메소드의 이름을 `get_analysis_history_by_user_id`로 변경하여 명확성을 높였습니다. `AnalysisService`에 있던 DB 로직을 이전하여, 분석 결과를 생성하는 `create_analysis_result`와 모든 결과를 조회하는 `get_all_analysis_results` 메소드를 추가했습니다.
- **`style_log_repository.py` (생성)**: `AnalysisService`가 처리하던 `style_logs` 테이블 관련 쿼리를 캡슐화하기 위해 새로운 `StyleLogRepository`를 생성하고, `get_all_style_logs` 메소드를 추가했습니다.
- **`dependencies/repositories.py` (수정)**: 새로 생성된 `StyleLogRepository`를 주입하기 위한 `get_style_log_repository` 의존성 함수를 추가했습니다.

### 3.2. 서비스 계층 리팩토링 (`analysis_service.py`)
- **생성자 수정**: `__init__` 메소드가 `UserRepository`, `AnalysisRepository`, `StyleLogRepository` 인스턴스를 모두 주입받도록 변경했습니다.
- **`conn` 인자 제거**: 모든 메소드 시그니처에서 데이터베이스 연결 객체(`conn`)를 제거했습니다.
- **내부 로직 수정**: 모든 데이터베이스 직접 호출(`conn.execute`, `conn.fetch`) 코드를, 해당 책임을 가진 레포지토리의 메소드 호출로 변경했습니다. (`self.analysis_repo.create_analysis_result(...)`, `self.style_log_repo.get_all_style_logs(...)` 등)

### 3.3. 의존성 주입 체인 수정 (`dependencies/services.py`)
- **`get_analysis_service` 함수 추가**: 필요한 모든 레포지토리 의존성 함수(`get_user_repository` 등)를 사용하여 `AnalysisService`의 인스턴스를 생성하고 반환하는 새로운 의존성 주입 함수를 추가했습니다.

### 3.4. 라우터 계층 리팩토링 (`analysis_router.py`)
- **의존성 변경**: 라우터가 DB에 직접 의존하던 `get_db_connection`을 제거하고, 새로 만든 `get_analysis_service`를 통해 서비스 계층에만 의존하도록 수정했습니다.
- **코드 간소화**: 서비스 메소드(`process_csv`) 호출 시 `conn`을 전달하는 코드를 제거하여 라우터의 역할을 단순화했습니다.

## 4. 최종 결과 (Final Outcome)
- 모든 서버 시동 오류가 해결되었습니다.
- 이제 애플리케이션의 모든 부분이 일관된 3-Tier 아키텍처(Controller-Service-Repository)를 따르게 되어, 코드의 예측 가능성, 유지보수성, 테스트 용이성이 크게 향상되었습니다.

